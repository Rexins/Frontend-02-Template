<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body oncontextmenu="event.preventDefault()">
    <script>
      let element = document.documentElement;
			let isListeningMouse = false
			element.addEventListener('tap', () => {
				console.log('tap')
			})
      element.addEventListener("mousedown", (event) => {
				const context = Object.create(null)
				contexts.set("mouse" + (1 << event.button), context)
        start(event, context);
        let mousemove = (event) => {
					let button = 1
					while (button <= event.buttons) {
						if (button & event.buttons) {
							let key;
							if (button === 2)
								key = 4
							else if (button === 4)
								key = 2
							else
								key = button
							move(event, context);
						}
						button = button << 1
					}
        };
        let mouseup = (event) => {
					let context = contexts.get('mouse' + (1 << event.button))
          end(event, context);
					if (event.buttons = 0) {
						isListeningMouse = false
						document.removeEventListener("mousemove", mousemove);
						document.removeEventListener("mouseup", mouseup);
					}
        };
				if (!isListeningMouse) {
					isListeningMouse = true
					document.addEventListener("mousemove", mousemove);
					document.addEventListener("mouseup", mouseup);
				}
      });

      const contexts = new Map();
      element.addEventListener("touchstart", (event) => {
        for (let touch of event.changedTouches) {
          let context = Object.create(null);
          contexts.set(touch.identifier, context);
          start(touch, context);
        }
      });

      element.addEventListener("touchmove", (event) => {
        for (let touch of event.changedTouches) {
          const context = contexts.get(touch.identifier);
          move(touch, context);
        }
      });

      element.addEventListener("touchend", (event) => {
        for (let touch of event.changedTouches) {
          const context = contexts.get(touch.identifier);
          end(touch, context);
          contexts.delete(touch.identifier);
        }
      });

      element.addEventListener("touchcancel", (event) => {
        for (let touch of event.changedTouches) {
          let context = contexts.get(touch.identifier);
          cancel(touch, context);
          contexts.delete(touch.identifier);
        }
      });

      const start = (point, context) => {
        (context.startX = point.clientY), (context.startY = point.clientY);
        context.isPan = false;
        context.isPress = false;
        context.isTap = true;
        context.handler = setTimeout(() => {
          context.isPress = true;
          context.isPan = false;
          console.log("press");
        }, 500);

				context.points = [{
					v: Date.now(),
					x: point.clientX,
					y: point.clientY
				}]
      };
      const move = (point, context) => {
        let dx = point.clientX - context.startX,
          dy = point.clientY - context.startY;

        if (dx ** 2 + dy ** 2 > 100) {
          context.isPan = true;
          context.isPress = false;
          context.isTap = false;
          clearTimeout(context.handler);
        }

				if (context.isPan) {
					context.points.push({
						v: Date.now(),
						x: point.clientX,
						y: point.clientY
					})
				}
      };
      const end = (point, context) => {
        if (context.isTap) {
          console.log("tap");
					dispatch('tap')
          clearTimeout(context.handler);
        }
        if (context.isPress) {
          console.log("pressend");
        }
        if (context.isPan) {
          console.log("panend");
        }

				context.points = context.points.filter(point => Date.now() - point.v < 500)

				let d, v;
				if (context.points.length === 0) {
					v = 0
				} else {
					d = Math.sqrt((point.clientX - context.points[0].x) ** 2 + (point.clientY - context.points[0].y) ** 2)
					v = d / (Date.now() - context.points[0].v)
				}

				if (v > 1.5) {
					console.log('flick')
					context.isFlick = true
				} else {
					context.isFlick = false
				}
      };
      const cancel = (point) => {
        clearTimeout(handler);
      };

			function dispatch(type, properties) {
				let event = new Event(type)
				for (let name in properties) {
					event[name] = properties[name]
				}

				element.dispatchEvent(event)
			}
    </script>
  </body>
</html>
